/*
 * Jexl
 * Copyright (c) 2015 TechnologyAdvice
 */

var Grammar = require('./Grammar');

/**
 * The Evaluator takes a Jexl expression tree as generated by the
 * {@link Parser} and calculates its value within a given context. The
 * collection of transforms, context, and a relative context to be used as the
 * root for relative identifiers, are all specific to an Evaluator instance.
 * When any of these things change, a new instance is required.  However, a
 * single instance can be used to simultaneously evaluate many different
 * expressions, and does not have to be reinstantiated for each.
 * @param {{}} transforms A map of transform names to transform functions. A
 *      transform function takes two arguments:
 *          - {*} val: A value to be transformed
 *          - {{}} args: A map of argument keys to their evaluated values, as
 *              specified in the expression string
 *      The transform function should return either the transformed value, or
 *      a Promises/A+ Promise object that resolves with the value and rejects
 *      or throws only when an unrecoverable error occurs. Transforms should
 *      generally return undefined when they don't make sense to be used on the
 *      given value type, rather than throw/reject. An error is only
 *      appropriate when the transform would normally return a value, but
 *      cannot due to some other failure.
 * @param {{}} context A map of variable keys to their values. This will be
 *      accessed to resolve the value of each non-relative identifier. Any
 *      Promise values will be passed to the expression as their resolved
 *      value.
 * @param {{}|Array<{}|Array>} relativeContext A map or array to be accessed
 *      to resolve the value of a relative identifier.
 * @constructor
 */
var Evaluator = function(transforms, context, relativeContext) {
	this._transforms = transforms || {};
	this._context = context || {};
	this._relContext = relativeContext || context;
};

/**
 * Evaluates an expression tree within the configured context.
 * @param {{}} ast An expression tree object
 * @returns {Promise<*>} resolves with the resulting value of the expression.
 */
Evaluator.prototype.eval = function(ast) {
	var self = this;
	return Promise.resolve().then(function() {
		return self['_eval' + ast.type].call(self, ast);
	});
};

/**
 * Simultaneously evaluates each expression within a map, and delivers the
 * response as a map with the same keys, but with the evaluated result for each
 * as their value.
 * @param {{}} map A map of expression names to expression trees to be
 *      evaluated
 * @returns {Promise<{}>} resolves with the result map.
 */
Evaluator.prototype.evalMap = function(map) {
	var keys = Object.keys(map),
		result = {};
	var asts = keys.map(function(key) {
		return this.eval(map[key]);
	}, this);
	return Promise.all(asts).then(function(vals) {
		vals.forEach(function(val, idx) {
			result[keys[idx]] = val;
		});
		return result;
	});
};

/**
 * Evaluates a BinaryExpression node by running the Grammar's evaluator for
 * the given operator.
 * @param {{type: 'BinaryExpression', operator: <string>, left: {},
 *      right: {}}} ast An expression tree with a BinaryExpression as the top
 *      node
 * @returns {Promise<*>} resolves with the value of the BinaryExpression.
 * @private
 */
Evaluator.prototype._evalBinaryExpression = function(ast) {
	return Promise.all([
		this.eval(ast.left),
		this.eval(ast.right)
	]).then(function(arr) {
		return Grammar.elements[ast.operator].eval(arr[0], arr[1]);
	});
};

/**
 * Evaluates a FilterExpression by applying it to the subject value.
 * @param {{type: 'FilterExpression', relative: <boolean>, expr: {},
 *      subject: {}}} ast An expression tree with a FilterExpression as the top
 *      node
 * @returns {Promise<*>} resolves with the value of the FilterExpression.
 * @private
 */
Evaluator.prototype._evalFilterExpression = function(ast) {
	var self = this;
	return this.eval(ast.subject).then(function(subject) {
		if (ast.relative)
			return self._filterRelative(subject, ast.expr);
		return self._filterStatic(subject, ast.expr);
	});
};

/**
 * Evaluates an Identifier by either stemming from the evaluated 'from'
 * expression tree or accessing the context provided when this Evaluator was
 * constructed.
 * @param {{type: 'Identifier', value: <string>, [from]: {}}} ast An expression
 *      tree with an Identifier as the top node
 * @returns {Promise<*>|*} either the identifier's value, or a Promise that
 *      will resolve with the identifier's value.
 * @private
 */
Evaluator.prototype._evalIdentifier = function(ast) {
	if (ast.from) {
		return this.eval(ast.from).then(function(context) {
			if (context === undefined)
				return undefined;
			if (Array.isArray(context))
				context = context[0];
			return context ? context[ast.value] : undefined;
		});
	}
	else {
		return ast.relative ? this._relContext[ast.value] :
			this._context[ast.value];
	}
};

/**
 * Evaluates a Literal by returning its value property.
 * @param {{type: 'Literal', value: <string|number|boolean>}} ast An expression
 *      tree with a Literal as its only node
 * @returns {string|number|boolean} The value of the Literal node
 * @private
 */
Evaluator.prototype._evalLiteral = function(ast) {
	return ast.value;
};

/**
 * Evaluates a Transform node by applying a function from the transforms map
 * to the subject value.
 * @param {{type: 'Transform', name: <string>, subject: {}}} ast An
 *      expression tree with a Transform as the top node
 * @returns {Promise<*>|*} the value of the transformation, or a Promise that
 *      will resolve with the transformed value.
 * @private
 */
Evaluator.prototype._evalTransform = function(ast) {
	var transform = this._transforms[ast.name];
	if (!transform)
		throw new Error("Transform '" + ast.name + "' is not defined.");
	return Promise.all([
		this.eval(ast.subject),
		this.evalMap(ast.args || {})
	]).then(function(arr) {
		return transform(arr[0], arr[1]);
	});
};

Evaluator.prototype._evalUnaryExpression = function(ast) {
	return this.eval(ast.right).then(function(right) {
		return Grammar.elements[ast.operator].eval(right);
	});
};

/**
 * Applies a filter expression with relative identifier elements to a subject.
 * The intent is for the subject to be an array of subjects that will be
 * individually used as the relative context against the provided expression
 * tree. Only the elements whose expressions result in a truthy value will be
 * included in the resulting array.
 *
 * If the subject is not an array of values, it will be converted to a single-
 * element array before running the filter.
 * @param {*} subject The value to be filtered; usually an array. If this value is
 *      not an array, it will be converted to an array with this value as the
 *      only element.
 * @param {{}} expr The expression tree to run against each subject. If the
 *      tree evaluates to a truthy result, then the value will be included in
 *      the returned array; otherwise, it will be eliminated.
 * @returns {Promise<Array>} resolves with an array of values that passed the
 *      expression filter.
 * @private
 */
Evaluator.prototype._filterRelative = function(subject, expr) {
	var promises = [];
	if (!Array.isArray(subject))
		subject = [subject];
	subject.forEach(function(elem) {
		var evalInst = new Evaluator(this._transforms, this._context, elem);
		promises.push(evalInst.eval(expr));
	}, this);
	return Promise.all(promises).then(function(values) {
		var results = [];
		values.forEach(function(value, idx) {
			if (value)
				results.push(subject[idx]);
		});
		return results;
	});
};

/**
 * Applies a static filter expression to a subject value.  If the filter
 * expression evaluates to boolean true, the subject is returned; if false,
 * undefined.
 *
 * For any other resulting value of the expression, this function will attempt
 * to respond with the property at that name or index of the subject.
 * @param {*} subject The value to be filtered.  Usually an Array (for which
 *      the expression would generally resolve to a numeric index) or an
 *      Object (for which the expression would generally resolve to a string
 *      indicating a property name)
 * @param {{}} expr The expression tree to run against the subject
 * @returns {Promise<*>} resolves with the value of the drill-down.
 * @private
 */
Evaluator.prototype._filterStatic = function(subject, expr) {
	return this.eval(expr).then(function(res) {
		if (typeof res === 'boolean')
			return res ? subject : undefined;
		return subject[res];
	});
};

module.exports = Evaluator;
